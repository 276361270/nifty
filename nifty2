#!/usr/bin/env escript
-module(test).
-export([main/1]).

test_header(Header, Module, CompileOptions) ->
	io:format("processing ~s -> ~s ~s ~n", [Header, Module++"_nif.c", Module++".erl"]),
	% c parse stuff
	PathToH = Header,
	{Token, _} = clang_parse:parse([PathToH|CompileOptions]),
	{Functions, Typedefs, Structs} = clang_parse:build_vars(Token),
	{Types, Symbols} = type_table:build({Functions, Typedefs, Structs}),
	% template stuff
	CTemplate = erlang:list_to_atom("C"++Header),
	ETemplate = erlang:list_to_atom("E"++Header),
	ok = erlydtl:compile(
		"templates_new/cmodule.tpl",
		CTemplate,
		[{force_recompile, true},
	   {custom_tags_modules, [nifty_tags]},
	   {custom_filters_modules, [nifty_filters]}]),
	%ok = erlydtl:compile("templates_new/emodule.tpl", ETemplate),
	RenderVars = [
		{"functions", Functions},  % ?
		{"structs", Structs},      % ?
		{"typedefs", Typedefs},    % ? 
		{"module", Module},
		{"header", Header},
		{"types", Types},
		{"symbols", Symbols},
		{"root", filename:dirname(escript:script_name())++"/"},
		{"ets", ets:new(nifty_template_ets, [])},
		{"none", none}
		],
	{ok, COutput} = CTemplate:render(RenderVars),
 	%{ok, EOutput} = ETemplate:render(RenderVars),
	ok = file:write_file(Module++"_nif.c", io_lib:fwrite("~s", [COutput])),
	%ok = file:write_file(Module++".erl", io_lib:fwrite("~s", [EOutput])),
	ok.

main([Header, Module| Options]) ->
	true = code:add_pathz(filename:dirname(escript:script_name())++ "/src"),
	test_header(Header, Module, Options);
main(_) ->
	io:format("Error~n").
